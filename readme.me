Chapter02:
	item01:用静态工厂方法代替构造器
	item02:遇到多个构造器参数时，用构建器builder
	item03:用私有构造器活着枚举类型强化Singleton属性，通过枚举类型来实现单例是最理想的。
	item04:通过私有构造器强化不可实例化的能力，如工具类
	item05:避免创建不必要的对象
	item06:消除过期对象引用，应该认为是一种例外而不是规范，否则代码混乱，除非在紧凑型作用域范围内。常见：1.类是自己管理内存的;2.缓存--用WeakHashMap代表缓存;3.监听器和回调，同2。借助JProfiler等内存检测工具来发现内存泄漏问题。
	item07:避免使用终结方法finalizer()

Chapter03:
	item08:覆盖equals时请遵守通用约定:1.非值类equals应与其对象本身相等（无需覆盖）；2.父类已实现，子类继承即可/在继承时添加新属性时，建议复合优先于继承;3.私有/包级私有，equals永远不会被调用;
	item09:覆盖equals时总要覆盖hashCode，相等的对象具有相同的散列，而不相等的对象不一定具有不相同的散列。若类是不可变的，则可将hashcode作为类的一个域，避免重复计算；
	item10:始终覆盖toString
	item11:谨慎覆盖clone;object.clone()是一个浅拷贝
	item12:考虑实现Comparable接口，相关Comparator

Chapter04:
	item13:使类和成员的可访问性最小化
	item14:在公有类中使用访问方法而非公有域
	item15:使可变性最小化-->不可变类:1.不提供任何修改对象状态的方法;2.保证该类不会被扩展(final);3.所有域都是final的;4.所有域都为私有的;5.确保对于任何可变组件的互斥访问，并且不可变对象本质上是线程安全的，不要求同步;
	item16:复合优先于继承(这里的继承指的是clz extends clz，不包括clz implements interface，interface extends interface)
	item17:要么为继承而设计，并提供文档说明，要么就禁止继承

