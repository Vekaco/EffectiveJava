Chapter02:
	item01:用静态工厂方法代替构造器
	item02:遇到多个构造器参数时，用构建器builder
	item03:用私有构造器活着枚举类型强化Singleton属性，通过枚举类型来实现单例是最理想的。
	item04:通过私有构造器强化不可实例化的能力，如工具类
	item05:避免创建不必要的对象
	item06:消除过期对象引用，应该认为是一种例外而不是规范，否则代码混乱，除非在紧凑型作用域范围内。常见：1.类是自己管理内存的;2.缓存--用WeakHashMap代表缓存;3.监听器和回调，同2。借助JProfiler等内存检测工具来发现内存泄漏问题。
	item07:避免使用终结方法finalizer()

Chapter03:
	item08:覆盖equals时请遵守通用约定:1.非值类equals应与其对象本身相等（无需覆盖）；2.父类已实现，子类继承即可/在继承时添加新属性时，建议复合优先于继承;3.私有/包级私有，equals永远不会被调用;
	item09:覆盖equals时总要覆盖hashCode，相等的对象具有相同的散列，而不相等的对象不一定具有不相同的散列。若类是不可变的，则可将hashcode作为类的一个域，避免重复计算；
	item10:始终覆盖toString
	item11:谨慎覆盖clone;object.clone()是一个浅拷贝
	item12:考虑实现Comparable接口，相关Comparator

Chapter04:
	item13:使类和成员的可访问性最小化
	item14:在公有类中使用访问方法而非公有域
	item15:使可变性最小化-->不可变类:1.不提供任何修改对象状态的方法;2.保证该类不会被扩展(final);3.所有域都是final的;4.所有域都为私有的;5.确保对于任何可变组件的互斥访问，并且不可变对象本质上是线程安全的，不要求同步;
	item16:复合优先于继承(这里的继承指的是clz extends clz，不包括clz implements interface，interface extends interface)
	item17:要么为继承而设计，并提供文档说明，要么就禁止继承
	item18:接口优于抽象类
	item19:接口只用于定义类型
	item20:类层次由于标签类
	item21:用函数对象表示策略
	item22:优先考虑静态成员类:1.嵌套类：静态成员类，内部类（非静态成员类，匿名类，局部类）

Chapter05:
	item23:请不要在新代码中使用原生态类型
	item24:消除非受检警告
	item25:列表优先于数组
	item26:优先考虑泛型
	item27:优先考虑泛型方法
	item28:利用优先通配符来提升API的灵活性. PECS表示producer-extends, consumer-super
	item29:优先考虑类型安全的异构容器

Chapter06:
	item30:用enum代替int常量
	item31:用实例域代替序数
	item32:用enumset代替位域
	item33:用enummap代替数索引
	item34:用接口模拟可伸缩枚举
	item35:注解优先于命名模式
	item36:坚持使用Override注解
	item37:用标记接口定义类型

Chapter07：
	item38:检查参数的有效性
	item39:必要时进行保护性拷贝
	item40:谨慎设计方法签名
	item41:慎用重载:覆盖机制是规范，重载机制是例外
	item42:慎用可变参数
	item43:返回零长度的数组活着集合，而不是null
	item44:为左右导出的API元素编写文档注释

Chapter08:
	item45:将局部变量的作用域最小化
	item46:for-each循环优先于传统的for循环,除过滤remove,转换改变元素，平行迭代外
	item47:了解和使用类库,不要重复造轮子
	item48:如果需要精确的答案，请避免使用float和double,他们不应该用于货币计算，因为他们只是近似值
	item49:基本类型优于装箱基本类型
	item50:吐过其他类型更合适，则尽量避免使用字符串。1.字符串不适合代替其他的值类型 2.字符串不适合代替枚举类型 3.字符串不适合代替聚集类型(新建类来表示聚集类型更为合适） 4.字符串也不适合代表能力表
	item51:当心字符串连接的性能，+连接符不适合用于大规模/反复拼接场景
	item52:通过接口引用对象，参数、返回值、变量和域都应该用接口来声明而非类对象引用，只有真正用构造器创建某个对象的时候才需要引用这个类对象。如果是类，则优先选择他的基类作为来引用，除非他没有基类或者他提供了基类/接口中不存在的新特性，则使用该类作为引用
	item53:接口优先于反射机制
	item54:谨慎的使用本地方法
	item55:谨慎地进行优化
	item56:遵守普遍接受的命名惯例

Chapter09:
	item57:只针对异常的情况才使用异常
	item58:对可恢复的情况使用受检异常，对编程错误使用运行时异常
	item59:避免不必要的使用受检异常
	item60:优先使用标准的异常
	item61:抛出与抽象相对应的异常
	item62:每个方法抛出的异常都要有文档(仅受检异常)
	item63:在细节消息中包含能捕获失败的信息
	item64:努力使失败保持原子性
	item65:不要忽略异常

Chapter10:
	item66:同步访问共享的可变数据,只需共享不需互斥用volatile，否则用synchronized或者原子类型如AtomLong.
	item67:避免过度同步,不要在同步区内部调用外部方法。
	item68:executor和task优先于线程
	item69:并发工具优先于wait和notify
